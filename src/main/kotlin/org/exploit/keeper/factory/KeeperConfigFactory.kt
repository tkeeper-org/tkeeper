package org.exploit.keeper.factory

import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory
import io.micronaut.context.annotation.Factory
import io.micronaut.context.annotation.Requires
import io.micronaut.core.annotation.Nullable
import jakarta.inject.Singleton
import org.exploit.keeper.config.audit.AuditConfig
import org.exploit.keeper.config.audit.AuditFileConfig
import org.exploit.keeper.config.audit.AuditSocketConfig
import org.exploit.keeper.config.auth.AuthConfig
import org.exploit.keeper.config.auth.JwtAuthConfig
import org.exploit.keeper.config.boot.BootConfig
import org.exploit.keeper.config.csp.KeeperContentSecurityConfig
import org.exploit.keeper.config.dev.DevConfig
import org.exploit.keeper.config.keeper.KeeperClientConfig
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.config.keeper.KeeperPeerConfig
import org.exploit.keeper.config.keeper.KeeperServerConfig
import org.exploit.keeper.config.seal.AwsProviderConfig
import org.exploit.keeper.config.seal.GoogleProviderConfig
import org.exploit.keeper.config.seal.SealConfig
import org.exploit.keeper.config.seal.ShamirProviderConfig
import org.exploit.keeper.config.session.SessionConfig
import org.exploit.keeper.config.session.SessionConfig.*
import org.exploit.keeper.extension.config.*
import org.exploit.sodium.ReadOnlyBuffer
import java.io.File
import java.net.URI
import java.nio.file.Paths
import java.time.Duration

@Factory
class KeeperConfigFactory {
    @Singleton
    fun rawConfig(): Config = loadConfig()

    @Singleton
    fun keeperConfig(cfg: Config): KeeperConfig = parseKeeper(cfg)

    @Singleton
    fun authConfig(cfg: Config): AuthConfig = parseAuth(cfg)

    @Singleton
    fun bootConfig(cfg: Config): BootConfig = parseBoot(cfg)

    @Nullable
    @Singleton
    @Requires(property = "keeper.dev.enabled", value = "true")
    fun devConfig(): DevConfig {
        val devCfg = loadDevConfig()

        return DevConfig(
            token = devCfg.str("token"),
            permissions = devCfg.strList("permissions")
        )
    }

    @Singleton
    fun contentSecurityConfig(cfg: Config): KeeperContentSecurityConfig = parseCsp(cfg)

    private fun parseCsp(cfg: Config): KeeperContentSecurityConfig {
        if (!cfg.hasPath("keeper.csp"))
            return KeeperContentSecurityConfig()

        val c = cfg.getConfig("keeper.csp")

        fun list(path: String, fallback: List<String>): List<String> =
            if (c.hasPath(path)) c.getStringList(path) else fallback

        return KeeperContentSecurityConfig(
            reportOnly = c.bool("report-only", false),

            defaultSrc = list("default-src", listOf("'self'")),
            baseUri = list("base-uri", listOf("'self'")),
            objectSrc = list("object-src", listOf("'none'")),
            frameAncestors = list("frame-ancestors", listOf("'none'")),

            scriptSrc = list("script-src", listOf("'self'")),
            styleSrc = list("style-src", listOf("'self'")),

            imgSrc = list("img-src", listOf("'self'", "data:")),
            fontSrc = list("font-src", listOf("'self'", "data:")),

            connectSrc = list("connect-src", listOf("'self'")),
            formAction = list("form-action", listOf("'self'")),

            connectExtra = list("connect-extra", emptyList()),
            formActionExtra = list("form-action-extra", emptyList()),
            imgExtra = list("img-extra", emptyList()),

            oidcAutoConnect = c.bool("oidc-auto-connect", true)
        )
    }

    private fun loadDevConfig(): Config {
        val property = System.getProperty("keeper.dev.config.location")
            ?: error("keeper.dev.config.location property must be set to load developer configuration")

        val external = parseExternalConfigs(property, prefix = "dev")
        val k = external.getConfig("keeper")
        val dev = k.getConfig("dev")

        return dev
    }

    private fun loadConfig(): Config {
        val profile = System.getProperty("keeper.profile")
            ?: System.getenv("KEEPER_PROFILE")

        val locProp = System.getProperty("keeper.config.location")
            ?: System.getenv("KEEPER_CONFIG_LOCATION")

        val external = parseExternalConfigs(locProp)

        val base = ConfigFactory.parseResourcesAnySyntax("application")
        val profileCfg = if (profile != null)
            ConfigFactory.parseResourcesAnySyntax("application-$profile")
        else ConfigFactory.empty()

        val ref = ConfigFactory.parseResourcesAnySyntax("reference")
        val sysProps = ConfigFactory.systemProperties()

        return sysProps.withFallback(external)
            .withFallback(profileCfg)
            .withFallback(base)
            .withFallback(ref)
            .resolve()
    }

    private fun parseBoot(c: Config): BootConfig {
        val b = c.getConfig("boot")

        return BootConfig(
            token = ReadOnlyBuffer(b.str("token").toByteArray())
        )
    }

    private fun parseExternalConfigs(locations: String?, prefix: String = "application"): Config {
        if (locations.isNullOrBlank()) return ConfigFactory.empty()

        val parts = locations.split(',')
            .map { it.trim() }
            .filter { it.isNotEmpty() }

        return parts.fold(ConfigFactory.empty()) { acc, loc ->
            acc.withFallback(loadOneLocation(loc, prefix))
        }
    }

    private fun loadOneLocation(loc: String, prefix: String = "application"): Config {
        return when {
            loc.startsWith("classpath:") ->
                ConfigFactory.parseResourcesAnySyntax(loc.removePrefix("classpath:"))

            loc.startsWith("http://") || loc.startsWith("https://") ->
                ConfigFactory.parseURL(URI.create(loc).toURL())

            else -> {
                val f = File(loc)
                when {
                    f.isDirectory -> {
                        val candidates = listOf("$prefix.conf", "$prefix.json", "$prefix.properties")

                        val found = candidates.firstOrNull { File(f, it).exists() }
                            ?: error("No config file found in directory: $loc")

                        ConfigFactory.parseFile(File(f, found))
                    }
                    f.exists() -> ConfigFactory.parseFile(f)
                    else -> error("Config location not found: $loc")
                }
            }
        }
    }

    private fun parseKeeper(cfg: Config): KeeperConfig {
        val k = cfg.getConfig("keeper")

        val peers = if (k.has("peers")) {
            k.getConfigList("peers").map {
                KeeperPeerConfig(
                    id = it.int("id", 0),
                    internalUrl = it.str("internal-url")
                )
            }
        } else emptyList()

        val audit = k.getConfig("audit")

        val providers = if (k.has("providers")) k.getConfig("providers") else ConfigFactory.empty()
        val sealSelected = providers.str("selected", "shamir")

        val awsCfg = if (providers.has("aws")) {
            val a = providers.getConfig("aws")
            AwsProviderConfig(
                keyId = a.str("key-id"),
                region = a.str("region")
            )
        } else null

        val googleCfg = if (providers.has("google")) {
            val g = providers.getConfig("google")
            GoogleProviderConfig(
                project = g.str("project"),
                location = g.str("location"),
                keyRing = g.str("key-ring"),
                cryptoKey = g.str("crypto-key")
            )
        } else null

        val shamirCfg = if (providers.has("shamir")) {
            val s = providers.getConfig("shamir")
            ShamirProviderConfig(
                total = s.int("total", 3),
                threshold = s.int("threshold", 2)
            )
        } else null

        when (sealSelected) {
            "aws" -> requireNotNull(awsCfg) { "keeper.providers.aws must be set when selected=aws" }
            "google" -> requireNotNull(googleCfg) { "keeper.providers.google must be set when selected=google" }
            "shamir" -> requireNotNull(shamirCfg) { "keeper.providers.shamir must be set when selected=shamir" }
            else -> error("Unsupported providers.selected: $sealSelected")
        }

        val fileAudit = if (audit.has("file")) parseAuditFile(audit.getConfig("file")) else null
        val sockAudit = if (audit.has("socket")) parseAuditSocket(audit.getConfig("socket")) else null

        val servers = parseServers(k.getConfig("server"))

        return KeeperConfig(
            databasePath = k.getConfig("database").str("path", "data/keeper.db"),
            peers = peers,
            audit = AuditConfig(
                enabled = audit.bool("enabled", false),
                file = fileAudit,
                socket = sockAudit
            ),
            seal = SealConfig(
                selected = sealSelected,
                aws = awsCfg,
                google = googleCfg,
                shamir = shamirCfg
            ),
            session = parseSession(k),
            servers = servers,
            client = parseClient(k)
        )
    }

    private fun parseClient(s: Config): KeeperClientConfig =
        parseClientNode(s.getConfig("client"))

    private fun parseClientNode(c: Config): KeeperClientConfig =
        KeeperClientConfig(
            tls = c.bool("tls", false),
            idleTimeout = c.long("idle-timeout", 30_000),
            connectTimeout = c.long("connect-timeout", 500),
            trustStorePath = c.strOrNull("trust-store-path"),
            trustStorePassword = c.strOrNull("trust-store-password"),
        )

    private fun parseServers(s: Config): KeeperConfig.Servers =
        KeeperConfig.Servers(
            public = parseServerNode(s.getConfig("public")),
            internal = parseServerNode(s.getConfig("internal"))
        )

    private fun parseServerNode(s: Config): KeeperServerConfig {
        val tls = if (s.has("tls")) {
            val t = s.getConfig("tls")
            KeeperServerConfig.Tls(
                enabled = t.bool("enabled", false),

                keyStorePath = t.strOrNull("key-store-path")?.takeIf { it.isNotBlank() },
                keyStorePassword = t.strOrNull("key-store-password")?.takeIf { it.isNotBlank() },
                keyStoreType = t.strOrNull("key-store-type")?.takeIf { it.isNotBlank() },

                certificateChainPath = t.strOrNull("certificate-chain-path")?.takeIf { it.isNotBlank() },
                privateKeyPath = t.strOrNull("private-key-path")?.takeIf { it.isNotBlank() },
                privateKeyPassword = t.strOrNull("private-key-password")?.takeIf { it.isNotBlank() },
                refreshEvery = t.dur("refresh-every")
            )
        } else null

        return KeeperServerConfig(
            host = s.str("host", "localhost"),
            port = s.int("port", 8080),
            idleTimeout = s.dur("idle-timeout", Duration.ofSeconds(30)),
            maxRequestLength = s.bytes("max-request-length", 10 * 1024 * 1024),
            tls = tls
        )
    }

    private fun parseAuditFile(f: Config): AuditFileConfig =
        AuditFileConfig(
            directory = Paths.get(f.str("directory", "audit")),
            extension = f.str("extension", "ndjson"),
            maxFileSizeBytes = f.long("max-file-size-bytes", 64L * 1024 * 1024),
            prefix = f.str("prefix", "audit"),
            rollEvery = if (f.has("roll-every")) f.getDuration("roll-every") else null,
            maxFiles = f.int("max-files", 10),
            retentionDays = if (f.has("retention-days")) f.getInt("retention-days") else null,
            gzip = f.bool("gzip", false),
            fsync = f.bool("fsync", false)
        )

    private fun parseAuditSocket(s: Config): AuditSocketConfig {
        val tls = if (s.has("tls")) {
            val t = s.getConfig("tls")
            val trust = if (t.has("trust")) {
                val tr = t.getConfig("trust")
                AuditSocketConfig.TrustConfig(
                    mode = tr.str("mode", "system"),
                    path = tr.strOrNull("path"),
                    password = tr.strOrNull("password"),
                    type = tr.str("type", "JKS")
                )
            } else null

            val client = if (t.has("client")) {
                val c = t.getConfig("client")
                AuditSocketConfig.ClientConfig(
                    keystorePath = c.strOrNull("keystore-path"),
                    keystorePassword = c.strOrNull("keystore-password"),
                    keystoreType = c.str("keystore-type", "PKCS12")
                )
            } else null

            AuditSocketConfig.TlsConfig(
                protocols = if (t.has("protocols")) t.strList("protocols") else listOf("TLSv1.3","TLSv1.2"),
                verifyHostname = t.bool("verify-hostname", true),
                trust = trust,
                spkiPins = if (t.has("spki-pins")) t.strList("spki-pins") else null,
                client = client
            )
        } else null

        return AuditSocketConfig(
            host = s.str("host", "localhost"),
            port = s.int("port", 443),
            connectTimeoutMillis = s.int("connect-timeout-millis", 2000),
            readTimeoutMillis = s.int("read-timeout-millis", 2000),
            tcpNoDelay = s.bool("tcp-no-delay", true),
            keepAlive = s.bool("keep-alive", true),
            soLingerSeconds = s.int("so-linger-seconds", 0),
            tls = tls
        )
    }

    private fun parseSession(k: Config): SessionConfig {
        if (!k.has("session"))
            return SessionConfig()

        val s = k.getConfig("session")

        val ecies = roundOnlyConfig(s, "ecies", 3)
        val gg20 = expireWithRoundConfig(s, "gg20", 3, Duration.ofMinutes(15))
        val frost = expireWithRoundConfig(s, "frost", 5, Duration.ofMinutes(5))

        val dkg = expireOnlyConfig(s, "dkg", Duration.ofMinutes(5))
        val destroy = expireOnlyConfig(s, "destroy", Duration.ofMinutes(5))

        return SessionConfig(ecies = ecies, gg20 = gg20, frost = frost, dkg = dkg, destroy = destroy)
    }

    private fun roundOnlyConfig(root: Config, field: String, def: Int): SessionRoundOnlyConfig {
        if (!root.has(field))
            return SessionRoundOnlyConfig(def)

        val maxRounds = root.int("max-rounds", def)
        return SessionRoundOnlyConfig(maxRounds)
    }

    private fun expireWithRoundConfig(root: Config, field: String, maxRoundsDef: Int, expireDef: Duration): SessionWithRoundConfig {
        if (!root.has(field))
            return SessionWithRoundConfig(expireDef, maxRoundsDef)

        val config = root.getConfig(field)
        val expire = config.dur("expire", expireDef)
        val maxRounds = config.int("max-rounds", maxRoundsDef)

        return SessionWithRoundConfig(expire, maxRounds)
    }

    private fun expireOnlyConfig(root: Config, field: String, def: Duration): SessionExpireOnlyConfig {
        if (!root.has(field))
            return SessionExpireOnlyConfig(def)

        val config = root.getConfig(field)
        val expire = config.dur("expire", def)

        return SessionExpireOnlyConfig(expire)
    }

    private fun parseAuth(cfg: Config): AuthConfig {
        if (!cfg.hasPath("auth")) return AuthConfig(type = "dev", jwt = null)
        val a = cfg.getConfig("auth")
        val type = a.str("type", "dev")
        val jwt = if (a.has("jwt")) {
            val j = a.getConfig("jwt")
            JwtAuthConfig(
                jwksLocation = j.str("jwks-location"),
                refresh = if (j.has("refresh")) j.getDuration("refresh") else null,
                audience = j.str("audience"),
                oidc = if (j.has("oidc")) readOidcConfig(j.getConfig("oidc")) else null
            )
        } else null
        
        return AuthConfig(type = type, jwt = jwt)
    }

    private fun readOidcConfig(oidc: Config): JwtAuthConfig.OIDCConfig {
        return JwtAuthConfig.OIDCConfig(
            clientId = oidc.str("client-id"),
            discoveryUrl = oidc.str("discovery-url"),
            callbackUrl = oidc.str("callback-url")
        )
    }
}