package org.exploit.keeper.permission

class AntPermissionMatcher(pattern: String) {
    private val patternSegments: List<Segment> = parseSegments(pattern)

    fun match(permission: String): Boolean {
        val pathSegments = parseRawSegments(permission)
        require(pathSegments.isNotEmpty()) { "Bad permission: $permission" }

        if (patternSegments.size != pathSegments.size) return false

        return patternSegments.zip(pathSegments).all { (seg, value) -> seg.matches(value) }
    }

    private sealed class Segment {
        abstract fun matches(value: String): Boolean

        class Exact(private val expected: String) : Segment() {
            override fun matches(value: String): Boolean = expected == value
        }

        object FullWildcard : Segment() {
            override fun matches(value: String): Boolean = true
        }

        class Prefix(private val prefix: String) : Segment() {
            override fun matches(value: String): Boolean = value.startsWith(prefix)
        }

        class Suffix(private val suffix: String) : Segment() {
            override fun matches(value: String): Boolean = value.endsWith(suffix)
        }

        class Infix(private val prefix: String, private val suffix: String) : Segment() {
            override fun matches(value: String): Boolean =
                value.startsWith(prefix)
                        && value.endsWith(suffix)
                        && value.length >= prefix.length + suffix.length
        }
    }

    companion object {
        private val SEGMENT_SPLIT = "\\.".toRegex()

        private fun parseRawSegments(input: String): List<String> =
            input.split(SEGMENT_SPLIT).filter { it.isNotEmpty() }

        private fun parseSegments(pattern: String): List<Segment> =
            parseRawSegments(pattern).map { raw ->
                when {
                    raw == "**" -> throw IllegalArgumentException(
                        "Deep wildcard '**' is not allowed — permissions must be explicit per segment"
                    )
                    raw == "*" -> Segment.FullWildcard
                    !raw.contains('*') -> Segment.Exact(raw)
                    raw.endsWith('*') && raw.count { it == '*' } == 1 ->
                        Segment.Prefix(raw.removeSuffix("*"))
                    raw.startsWith('*') && raw.count { it == '*' } == 1 ->
                        Segment.Suffix(raw.removePrefix("*"))
                    raw.count { it == '*' } == 1 -> {
                        val (pre, suf) = raw.split('*', limit = 2)
                        Segment.Infix(pre, suf)
                    }
                    else -> throw IllegalArgumentException(
                        "Invalid pattern segment: '$raw' — max one wildcard per segment"
                    )
                }
            }
    }
}