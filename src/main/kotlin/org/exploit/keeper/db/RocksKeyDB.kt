package org.exploit.keeper.db

import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ECPublicKey
import org.exploit.crypto.key.ed25519.Ed25519KeyPair
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.ed25519.Ed25519
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.common.StoreState
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toByteArray
import org.exploit.keeper.extension.toInt
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.service.key.dek.DekOps
import org.exploit.keeper.service.key.kek.KekOps
import org.exploit.keeper.util.KeySerializer
import org.exploit.keeper.util.crypto.Random
import org.exploit.tss.util.ZKRandom
import org.rocksdb.*
import java.io.Closeable
import java.nio.charset.StandardCharsets
import java.util.concurrent.atomic.AtomicReference

class RocksKeyDB(private val dbPath: String) : Closeable {
    private val db: TransactionDB
    private val handles: MutableList<ColumnFamilyHandle> = ArrayList()

    val ops: AtomicReference<DekOps> = AtomicReference()

    val vault: LogicalKeyStore
    val destroy: DestroyStore
    val expire: ExpireStore
    val ownerIndex: OwnerIndexStore
    val meta: MetaStore
    val commits: CommitStore

    init {
        RocksDB.loadLibrary()
        val writeOpts = WriteOptions()
        val readOpts = ReadOptions()

        db = openDatabase(handles)

        val vaultKeyStore = KeyStoreOps(this, handles[1], writeOpts, readOpts) { requireDekOps() }
        val metaKeyStore = KeyStoreOps(this, handles[2], writeOpts, readOpts) { requireDekOps() }
        val expireKeyStore = KeyStoreOps(this, handles[3], writeOpts, readOpts) { requireDekOps()}
        val destroyKeyStore = KeyStoreOps(this, handles[4], writeOpts, readOpts) { requireDekOps() }
        val ownerIndexKeyStore = KeyStoreOps(this, handles[5], writeOpts, readOpts) { requireDekOps() }
        val commitKeyStore = KeyStoreOps(this, handles[6], writeOpts, readOpts) { requireDekOps() }

        vault = LogicalKeyStore( vaultKeyStore)
        destroy = DestroyStore(destroyKeyStore)
        expire = ExpireStore(expireKeyStore)
        ownerIndex = OwnerIndexStore(ownerIndexKeyStore)
        meta = MetaStore(metaKeyStore, expire, ownerIndex)
        commits = CommitStore(commitKeyStore)
    }

    fun state(): StoreState = when {
        !isInitialized() -> StoreState.UNINITIALIZED
        ops.get() == null -> StoreState.SEALED
        else -> StoreState.UNSEALED
    }

    fun rocksdb(): TransactionDB = db

    fun isInitialized(): Boolean = vault.ops.hasKey(SENTINEL_KEY)

    fun writeMasterKey(ops: KekOps): ByteArray {
        if (vault.ops.hasKey(MASTER_KEY))
            return ops.unwrapDek(vault.ops.getRaw(MASTER_KEY)!!)

        val randomKey = ByteArray(32)
        ZKRandom.getRandom().nextBytes(randomKey)

        val wrapped = ops.wrapDek(randomKey)
        vault.ops.saveRaw(MASTER_KEY, wrapped)

        return randomKey
    }

    fun readMasterKey(ops: KekOps): ByteArray =
        vault.ops.getRaw(MASTER_KEY)?.let { ops.unwrapDek(it) }
            ?: throw TKeeperException(ErrorType.KEEPER_NOT_INITIALIZED)

    fun writeSentinel(ops: DekOps) =
        vault.ops.saveRaw(SENTINEL_KEY, ops.encrypt(SENTINEL_VAL))

    fun checkValidKey(ops: DekOps): Boolean =
        vault.ops.getRaw(SENTINEL_KEY)
            ?.let { ops.decrypt(it).contentEquals(SENTINEL_VAL) }
            ?: false

    fun writeIntegrityKey(ops: DekOps) {
        vault.ops.runInTransaction {
            val currentVersion = vault.ops.getRaw(it, INTEGRITY_KEY_VERSION)
                ?.toInt()
                ?: 0

            val keyPair = Ed25519.generateKeyPair()

            try {
                val serialized = KeySerializer.serialize(
                    CurveName.ED25519,
                    keyPair.secretKey
                )
                val enc = ops.encrypt(serialized)
                val nextVersion = currentVersion + 1

                vault.ops.saveMultiRaw(it,
                    mapOf(
                        INTEGRITY_KEY.format(nextVersion) to enc,
                        INTEGRITY_KEY_VERSION to nextVersion.toByteArray()
                    )
                )
            } finally {
                keyPair.secretKey.fill(0)
            }
        }
    }

    fun writeIntegrityKey() {
        writeIntegrityKey(requireDekOps())
    }

    fun readIntegrityPublicKey(version: Int? = null): ECPublicKey<Ed25519PointOps> {
        val currentVersion = version ?: vault.ops.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
        ?: throw IllegalStateException("Integrity key version not found")

        val privateIntegrityKey = vault.ops.get(INTEGRITY_KEY.format(currentVersion))?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val sk = Ed25519PrivateKey(privateIntegrityKey.ski)

        return try {
            Ed25519Provider.getInstance().getPublicKey(sk) as Ed25519PublicKey
        } finally {
            sk.erase()
        }
    }

    fun readIntegrityKeyVersion(): Int =
        vault.ops.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
            ?: throw TKeeperException(ErrorType.HMAC_KEY_NOT_FOUND)

    fun readIntegrityKeyPair(version: Int? = null): Ed25519KeyPair {
        val currentVersion = version ?: vault.ops.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
        ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val privateIntegrityKey = vault.ops.get(INTEGRITY_KEY.format(currentVersion))?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val privateKey = Ed25519PrivateKey.create(privateIntegrityKey.ski) as Ed25519PrivateKey
        val publicKey = Ed25519Provider.getInstance().getPublicKey(privateKey) as Ed25519PublicKey

        return Ed25519KeyPair(privateKey, publicKey)
    }

    fun writeHmacKey(ops: DekOps) {
        val bytes = Random.bytes(32)

        try {
            vault.ops.runInTransaction {
                val currentVersion = vault.ops.getRaw(it, HMAC_KEY_VERSION)
                    ?.toInt()
                    ?: 0

                val nextVersion = currentVersion + 1

                vault.ops.saveMultiRaw(it,
                    mapOf(
                        HMAC_KEY.format(nextVersion) to ops.encrypt(bytes),
                        HMAC_KEY_VERSION to nextVersion.toByteArray()
                    )
                )
            }
        } finally {
            bytes.fill(0)
        }
    }

    fun readHmacKey(version: Int? = null): ByteArray {
        val currentVersion = version ?: vault.ops.getRaw(HMAC_KEY_VERSION)
            ?.toInt()
        ?: throw IllegalStateException("HMAC key version not found")

        return vault.ops.get(HMAC_KEY.format(currentVersion))
            ?: throw IllegalStateException("HMAC key not found")
    }

    fun readHmacKeyVersion(): Int =
        vault.ops.getRaw(HMAC_KEY_VERSION)
            ?.toInt()
            ?: throw TKeeperException(ErrorType.HMAC_KEY_NOT_FOUND)

    fun writeInitData(peerId: Int, threshold: Int, total: Int) {
        vault.ops.saveMultiRaw(
            mapOf(
                PEER_ID_KEY to peerId.toString().toByteArray(StandardCharsets.UTF_8),
                THRESHOLD_KEY to threshold.toString().toByteArray(StandardCharsets.UTF_8),
                TOTAL_PEERS_KEY to total.toString().toByteArray(StandardCharsets.UTF_8)
            )
        )
    }

    fun readInitData(): KeeperInitData {
        val peerId = vault.ops.getRaw(PEER_ID_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Peer ID not found")
        val threshold = vault.ops.getRaw(THRESHOLD_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Threshold not found")
        val totalPeers = vault.ops.getRaw(TOTAL_PEERS_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Total peers not found")

        return KeeperInitData(peerId, threshold, totalPeers)
    }

    private fun requireDekOps(): DekOps = ops.get()
        ?: throw TKeeperException(ErrorType.KEEPER_SEALED)

    private fun openDatabase(handles: MutableList<ColumnFamilyHandle>): TransactionDB {
        RocksDB.loadLibrary()

        val options = DBOptions()
            .setCreateIfMissing(true)
            .setCreateMissingColumnFamilies(true)

        val txnOptions = TransactionDBOptions()

        val cfDescs = listOf(
            ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY),
            ColumnFamilyDescriptor(VAULT_FAMILY.toByteArray()),
            ColumnFamilyDescriptor(META_FAMILY.toByteArray()),
            ColumnFamilyDescriptor(EXPIRE_FAMILY.toByteArray()),
            ColumnFamilyDescriptor(DESTROY_FAMILY.toByteArray()),
            ColumnFamilyDescriptor(OWNER_INDEX_FAMILY.toByteArray()),
            ColumnFamilyDescriptor(COMMIT_FAMILY.toByteArray())
        )

        return TransactionDB.open(options, txnOptions, dbPath, cfDescs, handles)
    }

    override fun close() {
        handles.forEach { it.close() }
        db.close()
    }

    private companion object {
        val SENTINEL_VAL = "BK-v1".toByteArray()

        const val MASTER_KEY = "__master_key__"

        const val HMAC_KEY = "__hmac_key__%s"
        const val HMAC_KEY_VERSION = "__hmac_key_version__"

        const val INTEGRITY_KEY_VERSION = "__integrity_key_version__"
        const val INTEGRITY_KEY = "__integrity__%s"

        const val SENTINEL_KEY = "__sentinel__"

        const val PEER_ID_KEY = "__peer_id__"
        const val THRESHOLD_KEY = "__threshold__"
        const val TOTAL_PEERS_KEY = "__total_peers__"

        const val VAULT_FAMILY = "cf_vault"
        const val META_FAMILY = "cf_meta"
        const val EXPIRE_FAMILY = "cf_expire"
        const val DESTROY_FAMILY = "cf_destroy"
        const val OWNER_INDEX_FAMILY = "cf_owner_index"
        const val COMMIT_FAMILY = "cf_commitments"
    }
}