package org.exploit.keeper.service.auth.external

import com.nimbusds.jose.crypto.ECDSAVerifier
import com.nimbusds.jose.crypto.RSASSAVerifier
import com.nimbusds.jose.jwk.ECKey
import com.nimbusds.jose.jwk.JWK
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jwt.SignedJWT
import org.exploit.keeper.config.auth.JwtAuthConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.auth.AuthData
import org.exploit.keeper.model.auth.SimpleAuthData
import org.exploit.keeper.model.auth.plane.ControlPlaneAuthConfig
import org.exploit.keeper.model.auth.plane.HeaderTokenAuthConfig
import org.exploit.keeper.model.auth.plane.OIDCAuthConfig
import org.slf4j.LoggerFactory
import java.io.Closeable
import java.io.FileInputStream
import java.net.URI
import java.nio.file.Paths
import java.time.Duration
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference

class JwtMachineAuthenticator(private val config: JwtAuthConfig): TokenRequestAuthenticator, Closeable {
    private val jwksCache = JwkCache(config.jwksLocation, config.refresh ?: Duration.ofMinutes(15))

    override val type: String = ID
    override val requestHeader: String = REQUEST_HEADER

    override fun controlPlane(): ControlPlaneAuthConfig {
        val oidc = config.oidc

        return if (oidc == null) {
            HeaderTokenAuthConfig(REQUEST_HEADER)
        } else {
            OIDCAuthConfig(
                header = REQUEST_HEADER,
                clientId = oidc.clientId,
                audience = config.audience,
                discoveryUrl = oidc.discoveryUrl,
                callbackUrl = oidc.callbackUrl
            )
        }
    }

    override fun authenticate(token: String): AuthData {
        val signedJWT = parseJwt(token)

        val header = signedJWT.header
        val claims = signedJWT.jwtClaimsSet

        if (!claims.audience.contains(config.audience))
            throw TKeeperException(ErrorType.UNAUTHENTICATED, "Invalid audience")

        val keyId = header.keyID ?: throw TKeeperException(ErrorType.UNAUTHENTICATED, "Invalid key id")

        val publicKey = jwksCache.get(keyId)
        val verifier = when (publicKey) {
            is RSAKey -> RSASSAVerifier(publicKey)
            is ECKey -> ECDSAVerifier(publicKey)
            else -> throw TKeeperException(ErrorType.UNAUTHENTICATED,"Unsupported key type: ${publicKey.javaClass.simpleName}")
        }

        if (!signedJWT.verify(verifier)) {
            throw TKeeperException(ErrorType.UNAUTHENTICATED)
        }

        val subject = claims.subject ?: throw TKeeperException(ErrorType.UNAUTHENTICATED, "Invalid subject")

        val permissions = claims.getStringListClaim("permissions") ?: emptyList()

        return SimpleAuthData(subject = subject, permissions = permissions)
    }

    override fun close() {
        jwksCache.close()
    }

    private fun parseJwt(token: String): SignedJWT {
        return try {
            SignedJWT.parse(token)
        } catch (e: Exception) {
            error("Bad JWT")
        }
    }

    private class JwkCache(private val location: String, interval: Duration) : Closeable {
        private val ref = AtomicReference<JWKSet>()
        private val scheduler = Executors.newSingleThreadScheduledExecutor()

        init {
            ref.set(load())
            scheduler.scheduleAtFixedRate(
                { refresh() },
                interval.toMillis(),
                interval.toMillis(),
                TimeUnit.MILLISECONDS
            )
        }

        fun get(keyId: String): JWK =
            ref.get().getKeyByKeyId(keyId) ?: error("JWKS: no key with kid=$keyId")

        private fun load(): JWKSet {
            val uri = URI.create(location)
            return when (uri.scheme?.lowercase()) {
                "http", "https" -> JWKSet.load(URI.create(location).toURL())
                "file" -> Paths.get(uri).toFile().inputStream().use { JWKSet.load(it) }
                null -> FileInputStream(location).use { JWKSet.load(it) }
                else -> error("Unsupported URI scheme: ${uri.scheme}")
            }
        }

        private fun refresh() {
            try {
                ref.set(load())
            } catch (e: Exception) {
                LOGGER.error("Failed to reload JWKS", e)
            }
        }

        override fun close() {
            scheduler.shutdownNow()
        }

        companion object {
            private val LOGGER = LoggerFactory.getLogger(JwkCache::class.java)
        }
    }

    companion object {
        const val ID = "jwt"
        const val REQUEST_HEADER = "X-JWT-TOKEN"
    }
}

