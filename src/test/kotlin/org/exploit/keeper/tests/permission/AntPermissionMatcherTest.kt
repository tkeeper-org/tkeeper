package org.exploit.keeper.tests.permission

import org.exploit.keeper.permission.AntPermissionMatcher
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import org.junit.jupiter.params.provider.ValueSource
import kotlin.test.assertFalse
import kotlin.test.assertTrue

class AntPermissionMatcherTest {

    @Nested
    inner class ExactMatch {
        @Test
        fun `exact pattern matches identical permission`() {
            val matcher = AntPermissionMatcher("tkeeper.key.wallet-hot.sign")
            assertTrue(matcher.match("tkeeper.key.wallet-hot.sign"))
        }

        @Test
        fun `exact pattern rejects different permission`() {
            val matcher = AntPermissionMatcher("tkeeper.key.wallet-hot.sign")
            assertFalse(matcher.match("tkeeper.key.wallet-hot.decrypt"))
        }

        @Test
        fun `exact pattern rejects partial match`() {
            val matcher = AntPermissionMatcher("tkeeper.key.wallet-hot.sign")
            assertFalse(matcher.match("tkeeper.key.wallet-hot"))
        }

        @Test
        fun `exact pattern rejects longer path`() {
            val matcher = AntPermissionMatcher("tkeeper.key.wallet-hot")
            assertFalse(matcher.match("tkeeper.key.wallet-hot.sign"))
        }
    }

    @Nested
    inner class FullWildcard {
        @Test
        fun `wildcard segment matches any single segment`() {
            val matcher = AntPermissionMatcher("tkeeper.key.*.sign")
            assertTrue(matcher.match("tkeeper.key.wallet-hot.sign"))
            assertTrue(matcher.match("tkeeper.key.master-root.sign"))
            assertTrue(matcher.match("tkeeper.key.anything.sign"))
        }

        @Test
        fun `wildcard does not match across segment boundaries`() {
            val matcher = AntPermissionMatcher("tkeeper.key.*.sign")
            assertFalse(matcher.match("tkeeper.key.ns1.wallet-hot.sign"))
        }

        @Test
        fun `multiple wildcards work independently`() {
            val matcher = AntPermissionMatcher("tkeeper.*.*.sign")
            assertTrue(matcher.match("tkeeper.key.wallet-hot.sign"))
            assertTrue(matcher.match("tkeeper.whatever.anything.sign"))
            assertFalse(matcher.match("tkeeper.key.sign"))
        }
    }

    @Nested
    inner class PrefixWildcard {
        private val matcher = AntPermissionMatcher("tkeeper.key.wallet:*.sign")

        @ParameterizedTest
        @ValueSource(strings = [
            "tkeeper.key.wallet:hot.sign",
            "tkeeper.key.wallet:cold.sign",
            "tkeeper.key.wallet:btc-prod.sign"
        ])
        fun `prefix wildcard matches values with given prefix`(permission: String) {
            assertTrue(matcher.match(permission))
        }

        @ParameterizedTest
        @ValueSource(strings = [
            "tkeeper.key.vault:hot.sign",
            "tkeeper.key.master:root.sign",
            "tkeeper.key.wallet.sign"
        ])
        fun `prefix wildcard rejects values without prefix`(permission: String) {
            assertFalse(matcher.match(permission))
        }

        @Test
        fun `prefix wildcard matches value that equals prefix exactly`() {
            assertTrue(matcher.match("tkeeper.key.wallet:.sign"))
        }
    }

    @Nested
    inner class SuffixWildcard {
        private val matcher = AntPermissionMatcher("tkeeper.key.*-hot.sign")

        @ParameterizedTest
        @ValueSource(strings = [
            "tkeeper.key.wallet-hot.sign",
            "tkeeper.key.vault-hot.sign",
            "tkeeper.key.custody-btc-hot.sign"
        ])
        fun `suffix wildcard matches values with given suffix`(permission: String) {
            assertTrue(matcher.match(permission))
        }

        @ParameterizedTest
        @ValueSource(strings = [
            "tkeeper.key.wallet-cold.sign",
            "tkeeper.key.hot.sign",
            "tkeeper.key.hot-wallet.sign"
        ])
        fun `suffix wildcard rejects values without suffix`(permission: String) {
            assertFalse(matcher.match(permission))
        }
    }

    @Nested
    inner class InfixWildcard {
        private val matcher = AntPermissionMatcher("tkeeper.key.custody-*-prod.sign")

        @ParameterizedTest
        @CsvSource(
            "tkeeper.key.custody-btc-prod.sign, true",
            "tkeeper.key.custody-eth-prod.sign, true",
            "tkeeper.key.custody-sol-v2-prod.sign, true",
            "tkeeper.key.custodyprod.sign, false",
            "tkeeper.key.custody--prod.sign, true",
            "tkeeper.key.custody-btc-staging.sign, false",
            "tkeeper.key.wallet-btc-prod.sign, false"
        )
        fun `infix wildcard matches correctly`(permission: String, expected: Boolean) {
            if (expected) assertTrue(matcher.match(permission))
            else assertFalse(matcher.match(permission))
        }

        @Test
        fun `infix requires minimum length of prefix plus suffix`() {
            val m = AntPermissionMatcher("ab*cd")
            assertTrue(m.match("abcd"))
            assertTrue(m.match("ab-cd"))
            assertFalse(m.match("abc"))
            assertFalse(m.match("acd"))
        }
    }

    @Nested
    inner class SegmentCountStrict {
        @Test
        fun `different segment count always rejects`() {
            val matcher = AntPermissionMatcher("tkeeper.key.*.sign")
            assertFalse(matcher.match("tkeeper.key.sign"))
            assertFalse(matcher.match("tkeeper.key.a.b.sign"))
            assertFalse(matcher.match("tkeeper"))
        }
    }

    @Nested
    inner class InvalidPatterns {
        @Test
        fun `deep wildcard is explicitly forbidden`() {
            val ex = assertThrows<IllegalArgumentException> {
                AntPermissionMatcher("tkeeper.key.**.sign")
            }
            assertTrue(ex.message!!.contains("Deep wildcard"))
        }

        @Test
        fun `multiple wildcards in one segment are forbidden`() {
            assertThrows<IllegalArgumentException> {
                AntPermissionMatcher("tkeeper.key.a*b*c.sign")
            }
        }

        @Test
        fun `empty permission string fails require`() {
            val matcher = AntPermissionMatcher("tkeeper.key.*.sign")
            assertThrows<IllegalArgumentException> {
                matcher.match("")
            }
        }
    }

    @Nested
    inner class RealWorldPermissions {
        @ParameterizedTest
        @CsvSource(
            "tkeeper.key.wallet-*.sign,     tkeeper.key.wallet-hot.sign,       true",
            "tkeeper.key.wallet-*.sign,     tkeeper.key.wallet-cold.sign,      true",
            "tkeeper.key.wallet-*.sign,     tkeeper.key.master-root.sign,      false",
            "tkeeper.key.custody-*.decrypt, tkeeper.key.custody-btc.decrypt,   true",
            "tkeeper.key.custody-*.decrypt, tkeeper.key.custody-btc.sign,      false",
            "tkeeper.key.*.public,          tkeeper.key.anything.public,       true",
            "tkeeper.key.*.public,          tkeeper.key.anything.sign,         false",
            "tkeeper.system.unseal,         tkeeper.system.unseal,             true",
            "tkeeper.system.unseal,         tkeeper.system.seal,               false",
            "tkeeper.dkg.gg20,              tkeeper.dkg.gg20,                  true",
            "tkeeper.dkg.gg20,              tkeeper.dkg.frost,                 false"
        )
        fun `real-world permission scenarios`(pattern: String, permission: String, expected: Boolean) {
            val matcher = AntPermissionMatcher(pattern.trim())
            if (expected) assertTrue(matcher.match(permission.trim()))
            else assertFalse(matcher.match(permission.trim()))
        }
    }
}